<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>GPS+IMU ログ＆表示</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        #map { width: 100%; height: 400px; }
        button { margin: 5px; }
        #dataInfo { margin-top: 10px; }
        #info { margin-top: 10px; max-height: 200px; overflow-y: auto; }
        .error { color: red; font-weight: bold; }
        .info { color: green; }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.8.0/dist/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.1/purify.min.js"></script>
</head>
<body>
    <h2>GPS+IMU ログ＆表示</h2>
    <div><b>モード:</b> {{ 'ダミーモード' if dummy_mode else '実機モード' }}</div>
    <button id="logStartBtn">ログ開始</button>
    <button id="logStopBtn" disabled>ログ停止</button>
    <button id="toggleCoordBtn">座標系: 緯度経度</button>
    <label for="intervalInput">更新間隔:</label>
    <input type="number" id="intervalInput" value="1000" min="100" max="60000" step="100"> ms
    <div id="map"></div>
    <div id="dataInfo"></div>
    <div id="info"></div>

    <script>
    (() => {
        // 定数宣言
        const METERS_PER_DEGREE = 111320;
        const MAX_INFO_MESSAGES = 20;
        // ベースライン・扇形サイズ算出用定数
        const BASELINE_BASE = 0.7;
        const BASELINE_EXP = 1.2;
        const BASELINE_MAX = 10;
        const BASELINE_MIN = 0.1;
        const SECTOR_BASE = 1.0;
        const SECTOR_EXP = 1.2;
        const SECTOR_MAX = 15;
        const SECTOR_MIN = 0.2;

        // テンプレート変数
        const DUMMY_MODE = {{ 'true' if dummy_mode else 'false' }};
        // 状態変数
        let map, overlayGroup, marker, baselineLine, sectorCircle;
        let logActive = false, currentCoordType = "latlon";
        let intervalMs = 1000, intervalId = null;

        // 地図初期化
        function initMap() {
            map = L.map('map').setView([0, 0], 16);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
            overlayGroup = L.layerGroup().addTo(map);
            marker = L.marker([0, 0]).addTo(overlayGroup);
        }

        // ズームレベルに応じた線や扇形サイズ
        function getBaselineLengthByZoom(zoom) {
            if (zoom < 1 || zoom > 19) {
                console.warn(`Invalid zoom level: ${zoom}`);
                zoom = Math.min(Math.max(zoom, 1), 19);
            }
            return Math.min(BASELINE_MAX, Math.max(BASELINE_MIN, BASELINE_BASE * Math.pow(BASELINE_EXP, 16 - zoom)));
        }
        function getSectorRadiusByZoom(zoom) {
            if (zoom < 1 || zoom > 19) {
                console.warn(`Invalid zoom level: ${zoom}`);
                zoom = Math.min(Math.max(zoom, 1), 19);
            }
            return Math.min(SECTOR_MAX, Math.max(SECTOR_MIN, SECTOR_BASE * Math.pow(SECTOR_EXP, 16 - zoom)));
        }

        // 緯度経度⇔UTM変換
        function latlonToUTM(lat, lon, zone) {
            let proj4str = `+proj=utm +zone=${zone} +north +ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
            let utmCoord = proj4('WGS84', proj4str, [lon, lat]);
            return { x: utmCoord[0], y: utmCoord[1] };
        }
        function utmToLatlon(x, y, zone) {
            let proj4str = `+proj=utm +zone=${zone} +north +ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
            let latlon = proj4(proj4str, 'WGS84', [x, y]);
            return { lat: latlon[1], lon: latlon[0] };
        }

        // 地図・情報更新
        function updateMapDisplay(data) {
            let lat = data.lat, lon = data.lon;
            if (currentCoordType === "utm") {
                let utm = latlonToUTM(data.lat, data.lon, data.utm_zone);
                let latlon = utmToLatlon(utm.x, utm.y, data.utm_zone);
                lat = latlon.lat;
                lon = latlon.lon;
            }
            map.setView([lat, lon], map.getZoom());
            overlayGroup.clearLayers();
            marker = L.marker([lat, lon]).addTo(overlayGroup);

            let headingRad = data.heading * Math.PI / 180;
            const zoom = map.getZoom();
            const baselineLength = getBaselineLengthByZoom(zoom);
            const sectorRadius = getSectorRadiusByZoom(zoom);
            let lat2 = lat + (baselineLength * Math.cos(headingRad)) / METERS_PER_DEGREE;
            let lon2 = lon + (baselineLength * Math.sin(headingRad)) / (METERS_PER_DEGREE * Math.cos(lat * Math.PI / 180));
            baselineLine = L.polyline([[lat, lon], [lat2, lon2]], { color: 'red' }).addTo(overlayGroup);

            let sectorPoints = [];
            for (let angleDeg = data.heading - 10; angleDeg <= data.heading + 10; angleDeg += 2) {
                let rad = angleDeg * Math.PI / 180;
                let latp = lat + (sectorRadius * Math.cos(rad)) / METERS_PER_DEGREE;
                let lonp = lon + (sectorRadius * Math.sin(rad)) / (METERS_PER_DEGREE * Math.cos(lat * Math.PI / 180));
                sectorPoints.push([latp, lonp]);
            }
            sectorCircle = L.polygon([[lat, lon], ...sectorPoints], { color: 'orange', fillOpacity: 0.3 }).addTo(overlayGroup);

            const dataInfoDiv = document.getElementById("dataInfo");
            dataInfoDiv.innerHTML = '';
            const fields = [
                { label: '座標系', value: currentCoordType },
                { label: '緯度経度', value: `${data.lat.toFixed(7)}, ${data.lon.toFixed(7)}` },
                { label: 'UTM座標 (x,y)', value: `${data.utm_easting.toFixed(2)}, ${data.utm_northing.toFixed(2)} (Zone: ${data.utm_zone}${data.utm_letter})` },
                { label: 'HDOP', value: data.hdop },
                { label: 'VDOP', value: data.vdop },
                { label: '方位角', value: data.heading },
                { label: 'IMU (x,y,z)', value: `${data.imu_x.toFixed(3)}, ${data.imu_y.toFixed(3)}, ${data.imu_z.toFixed(3)}` }
            ];
            fields.forEach(field => {
                const p = document.createElement('p');
                p.innerHTML = `<b>${DOMPurify.sanitize(field.label)}:</b> ${DOMPurify.sanitize(field.value)}`;
                dataInfoDiv.appendChild(p);
            });
        }

        // メッセージ表示
        function showMessage(message, isError = false) {
            const infoDiv = document.getElementById("info");
            const msgDiv = document.createElement('div');
            msgDiv.className = isError ? 'error' : 'info';
            msgDiv.innerHTML = DOMPurify.sanitize(message);
            infoDiv.appendChild(msgDiv);
            while (infoDiv.children.length > MAX_INFO_MESSAGES) {
                infoDiv.removeChild(infoDiv.firstChild);
            }
            infoDiv.scrollTop = infoDiv.scrollHeight;
        }

        // センサーデータ取得
        async function fetchSensorData() {
            const maxRetries = 3;
            let attempts = 0;
            while (attempts < maxRetries) {
                try {
                    let res = await fetch("/get_data");
                    if (!res.ok) throw new Error(`データ取得に失敗しました: HTTPステータス ${res.status}`);
                    return await res.json();
                } catch (e) {
                    attempts++;
                    if (attempts === maxRetries) {
                        console.error("Fetch error after retries:", e);
                        showMessage(`エラー: センサーデータの取得に失敗しました（${attempts}回試行）: ${e.message}`, true);
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        // ログ開始
        function startLogging() {
            logActive = true;
            document.getElementById("logStartBtn").disabled = true;
            document.getElementById("logStopBtn").disabled = false;
            document.getElementById("intervalInput").disabled = true;
            showMessage("ログを開始しました。");

            async function loop() {
                if (!logActive) return;
                const data = await fetchSensorData();
                if (!data) {
                    intervalId = setTimeout(loop, intervalMs);
                    return;
                }
                updateMapDisplay(data);
                if (logActive) {
                    data.time = new Date().toISOString();
                    try {
                        let res = await fetch("/log", {
                            method: "POST",
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(data)
                        });
                        let result = await res.json();
                        if (!res.ok) throw new Error(result?.error || `ログ記録に失敗しました: HTTPステータス ${res.status}`);
                        showMessage("ログを記録しました。");
                    } catch (e) {
                        console.error("Log error:", e);
                        showMessage(`エラー: ログの記録に失敗しました: ${e.message}`, true);
                    }
                }
                if (logActive) intervalId = setTimeout(loop, intervalMs);
            }
            loop();
        }

        // ログ停止
        function stopLogging() {
            logActive = false;
            if (intervalId) {
                clearTimeout(intervalId); // setTimeoutで管理しているのでclearTimeoutが正しい
                intervalId = null;
            }
            document.getElementById("logStartBtn").disabled = false;
            document.getElementById("logStopBtn").disabled = true;
            document.getElementById("intervalInput").disabled = false;
            showMessage("ログを停止しました。");
        }

        // イベントバインド
        document.getElementById("logStartBtn").onclick = startLogging;
        document.getElementById("logStopBtn").onclick = stopLogging;
        document.getElementById("toggleCoordBtn").onclick = async () => {
            currentCoordType = currentCoordType === "latlon" ? "utm" : "latlon";
            document.getElementById("toggleCoordBtn").textContent = `座標系: ${currentCoordType === "latlon" ? "緯度経度" : "UTM"}`;
            const data = await fetchSensorData();
            if (data) updateMapDisplay(data);
        };
        document.getElementById("intervalInput").addEventListener("change", (e) => {
            let newInterval = parseInt(e.target.value) || 1000;
            intervalMs = Math.min(Math.max(newInterval, 100), 60000);
            if (intervalId) {
                clearTimeout(intervalId);
                intervalId = null;
                startLogging();
            }
        });

        // 起動時初期表示
        window.onload = async () => {
            initMap();
            const data = await fetchSensorData();
            if (data) {
                map.setView([data.lat, data.lon], 16);
                updateMapDisplay(data);
            }
        };
    })();
    </script>
</body>
</html>
